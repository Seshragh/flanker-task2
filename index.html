<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flanker Task v3 (Multi-Stage, New Noise)</title>
    <style>
        /* Basic CSS */
        body {
            font-family: Arial, sans-serif; text-align: center; background-color: #f8f9fa;
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        .container {
            max-width: 700px; width: 95%; padding: 20px; border: 1px solid #ccc; background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            box-sizing: border-box;
            display: flex; /* Use flexbox for easy screen switching */
            flex-direction: column; /* Stack content vertically */
        }

        /* --- Screen Visibility Control --- */
        .screen { display: none; /* Hide all screens by default */ width: 100%; }
        .screen.active { display: block; /* Show only the active screen */ }

        /* Task Stimulus Styling */
        #task #stimulus, #task #fixation {
            font-size: 60px; font-family: 'Courier New', Courier, monospace; margin: 30px 0;
            min-height: 70px; line-height: 70px; color: #333; /* Use min-height */
            white-space: pre;
            text-align: center; /* Ensure center alignment */
        }
        #task #fixation { font-size: 40px; }

        /* General Button Styling */
        button {
             padding: 10px 15px; font-size: 16px; cursor: pointer; margin: 10px 5px; /* Increased top/bottom margin */
             background-color: #007bff; color: white; border: none; border-radius: 4px;
             min-width: 100px; /* Ensure minimum width */
        }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }

        /* Form Styling */
        #participantInfo form { display: flex; flex-direction: column; gap: 12px; align-items: center; width: 100%; }
        #participantInfo .form-row { display: flex; justify-content: center; align-items: center; width: 90%; max-width: 400px;}
        #participantInfo label { margin-right: 10px; text-align: right; width: 100px; flex-shrink: 0;}
        #participantInfo input, #participantInfo select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; min-width: 150px; }

        /* Group Selection Styling */
        #groupSelection { margin-top: 20px; margin-bottom: 15px;}
        #groupSelection button { background-color: #6c757d; min-width: 120px; }
        #groupSelection button:hover:not(:disabled) { background-color: #5a6268; }
        #groupSelection button.selected { background-color: #28a745; border: 2px solid #1e7e34; } /* Style for selected group */
        #groupSelection button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.7;}

        /* Instructions / Text Styling */
        #instructions ul, #preTaskInstructions ul { list-style: none; padding: 0; margin: 15px 0; text-align: left; display: inline-block;}
        #instructions li, #preTaskInstructions li { margin-bottom: 10px; }
        #summary ul { list-style: none; padding: 0; text-align: left;}
        #summary li { margin-bottom: 8px; }
        h2 { margin-bottom: 20px;}
        p { margin: 10px 0; line-height: 1.5; }

        /* Feedback Styling */
        #feedback { font-size: 24px; font-weight: bold; margin-top: 20px; height: 30px; }
        .correct { color: green; }
        .incorrect { color: red; }
        .error-message { color: red; font-size: 14px; margin-top: 5px; font-weight: bold; }

        /* Touch Control Buttons Styling */
        #touchControls {
            display: flex; justify-content: center; flex-wrap: wrap; width: 100%;
            margin-top: 30px; gap: 15px;
        }
        #touchControls button {
            font-size: 20px; padding: 15px 25px; margin: 0 10px; cursor: pointer;
            border: 2px solid #007bff; background-color: #e7f1ff; color: #333;
            border-radius: 8px; min-width: 130px;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
        }
         #touchControls button:active { background-color: #cce0ff; transform: scale(0.98); }

         /* Eyes Closed Screen Styling */
         #eyesClosedCountdown {
            font-size: 48px; font-weight: bold; margin: 20px 0; color: #dc3545;
         }
         #eyesClosedText { font-size: 18px; margin-bottom: 20px;}

    </style>
</head>
<body>
    <div class="container">

        <div id="instructions" class="screen active">
            <h2>Welcome to the Experiment</h2>
            <p>Please read the instructions carefully.</p>
            <p>You will first be asked for some basic information and to select a group.</p>
            <p>This will be followed by a brief resting period with your eyes closed.</p>
            <p>Finally, you will perform the main letter identification task.</p>
             <p>Click "Continue" to enter your information.</p>
            <button id="continueToInfoBtn">Continue</button>
        </div>

        <div id="participantInfo" class="screen">
            <h2>Participant Information</h2>
            <form id="infoForm">
                 <div class="form-row">
                    <label for="participantId">Participant ID:</label>
                    <input type="text" id="participantId" name="participantId" required title="Enter any combination of letters/numbers">
                </div>
                <div class="form-row">
                    <label for="age">Age:</label>
                    <input type="number" id="age" name="age" required min="1" max="120">
                </div>
                <div class="form-row">
                    <label for="gender">Gender:</label>
                    <select id="gender" name="gender" required>
                        <option value="">--Please select--</option>
                        <option value="Male">Male</option>
                        <option value="Female">Female</option>
                        <option value="Non-binary">Non-binary</option>
                        <option value="Other">Other</option>
                        <option value="Prefer_not_to_say">Prefer not to say</option>
                    </select>
                 </div>

                 <div id="groupSelection">
                    <p>Please select your assigned group:</p>
                    <button type="button" id="group1Btn" data-group="Group 1">Group 1</button>
                    <button type="button" id="group2Btn" data-group="Group 2">Group 2</button>
                    <input type="hidden" id="selectedGroup" name="selectedGroup" value=""> </div>

                 <button type="submit" id="submitInfoBtn">Continue</button> <div id="infoError" class="error-message"></div> </form>
        </div>

         <div id="eyesClosedScreen" class="screen">
             <h2>Resting Period</h2>
             <p id="eyesClosedText">Please close your eyes for 3 minutes and be an impartial observer.</p>
             <div id="eyesClosedCountdown" style="display: none;">3:00</div>
             <button id="startCountdownBtn">Start 3 Minute Timer</button>
             <button id="continueAfterRestBtn" style="display: none;">Continue</button>
             <div id="countdownError" class="error-message"></div>
         </div>

        <div id="preTaskInstructions" class="screen">
            <h2>Task Instructions Reminder</h2>
            <p>Keep your eyes focused on the center of the screen where a '+' will appear.</p>
            <p>A letter (or sequence of letters) will appear briefly.</p>
            <p>Your task is to identify the <strong>center letter</strong>.</p>
             <ul id="instructionListReminder">
                 <li>Press <strong>F</strong> on your keyboard OR tap the <strong>[A / K (F)]</strong> button if the center letter is <strong>A</strong> or <strong>K</strong></li>
                 <li>Press <strong>J</strong> on your keyboard OR tap the <strong>[L / R (J)]</strong> button if the center letter is <strong>L</strong> or <strong>R</strong></li>
             </ul>
            <p>Please respond as quickly and accurately as possible.</p>
            <button id="startFlankerTaskBtn">Start Task</button>
        </div>

        <div id="task" class="screen">
            <div id="fixation">+</div>
            <div id="stimulus"></div> <div id="feedback"></div> <div id="touchControls">
                <button id="touchButtonF">A / K (F)</button>
                <button id="touchButtonJ">L / R (J)</button>
            </div>
        </div>

        <div id="summary" class="screen">
             <h2>Task Complete!</h2>
             <p>Here is a summary of your results:</p>
             <div id="summaryResults"></div>
             <button id="restartBtn">Restart Experiment</button>
        </div>

    </div> <script>
        // --- Get References ---
        const containerDiv = document.querySelector('.container'); // Get container for screen switching
        const screens = document.querySelectorAll('.container .screen'); // Get all screens
        const instructionsDiv = document.getElementById('instructions');
        const participantInfoDiv = document.getElementById('participantInfo');
        const eyesClosedScreenDiv = document.getElementById('eyesClosedScreen');
        const preTaskInstructionsDiv = document.getElementById('preTaskInstructions');
        const taskDiv = document.getElementById('task');
        const summaryDiv = document.getElementById('summary');

        const continueToInfoBtn = document.getElementById('continueToInfoBtn');
        const infoForm = document.getElementById('infoForm');
        const participantIdInput = document.getElementById('participantId');
        const ageInput = document.getElementById('age');
        const genderInput = document.getElementById('gender');
        const group1Btn = document.getElementById('group1Btn');
        const group2Btn = document.getElementById('group2Btn');
        const selectedGroupInput = document.getElementById('selectedGroup');
        const submitInfoBtn = document.getElementById('submitInfoBtn');
        const infoErrorDiv = document.getElementById('infoError');

        const eyesClosedText = document.getElementById('eyesClosedText');
        const eyesClosedCountdown = document.getElementById('eyesClosedCountdown');
        const startCountdownBtn = document.getElementById('startCountdownBtn');
        const continueAfterRestBtn = document.getElementById('continueAfterRestBtn');
        const countdownError = document.getElementById('countdownError');

        const instructionListReminder = document.getElementById('instructionListReminder'); // For pre-task screen
        const startFlankerTaskBtn = document.getElementById('startFlankerTaskBtn');

        const fixationDiv = document.getElementById('fixation');
        const stimulusDiv = document.getElementById('stimulus');
        const feedbackDiv = document.getElementById('feedback');
        // noiseOverlay reference removed
        const touchControlsDiv = document.getElementById('touchControls');
        const touchButtonF = document.getElementById('touchButtonF');
        const touchButtonJ = document.getElementById('touchButtonJ');

        const summaryResultsDiv = document.getElementById('summaryResults');
        const restartBtn = document.getElementById('restartBtn');

        // --- State Variables ---
        let trials = [];
        let currentTrialIndex = 0;
        let results = [];
        let summaryMetrics = {};
        let participantData = {}; // Will include id, age, gender, group
        let stimulusStartTime;
        let experimentStartTime; // Start time for the actual Flanker Task part
        let responseListener = null;
        let trialTimeoutId = null;
        let countdownIntervalId = null; // For the 3-minute timer

        // --- Timing Parameters ---
        const FIXATION_DURATION = 500;
        const FEEDBACK_DURATION = 750;
        const ITI = 500;
        const MAX_RESPONSE_TIME = 1500;
        const EYES_CLOSED_DURATION_SECONDS = 180; // 3 minutes

        // --- Configuration ---
        // IMPORTANT: Replace with YOUR actual Google Apps Script URL(s)
        // You might use one URL for both, or separate URLs if you prefer.
        // The Apps Script needs logic to handle both types of POST requests.
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/library/d/1oNlVEe91sLz8jgj_FSolPE6dW8efRunsM4V2F3ZVCTynp9Uz7JvrDA87/1"; // Replace!

        // --- Utility Functions ---
        function shuffleArray(array) { /* ... (same as before) ... */
             for (let i = array.length - 1; i > 0; i--) {
                 const j = Math.floor(Math.random() * (i + 1));
                 [array[i], array[j]] = [array[j], array[i]];
             }
             return array;
         }
        function calculateSD(data, mean) { /* ... (same as before) ... */
            if (!data || data.length < 2) return 0;
             const N = data.length;
             const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (N - 1);
             return Math.sqrt(variance);
        }
        function calculateMedian(data) { /* ... (same as before) ... */
            if (!data || data.length === 0) return 0;
             const sortedData = [...data].sort((a, b) => a - b);
             const mid = Math.floor(sortedData.length / 2);
             return sortedData.length % 2 === 0 ? (sortedData[mid - 1] + sortedData[mid]) / 2 : sortedData[mid];
        }

        // Modified for new 'noise' condition - only applies spacing if flankers exist
        function formatStimulus(stimulusString, spacingType, isNoiseTrial) {
            if (!isNoiseTrial || !stimulusString) { // No noise or empty string
                // Ensure single letter is centered - pad with spaces if needed
                // Simple approach: just return the single letter
                return stimulusString || '';
            }

            // Apply spacing only if it's a noise trial with flankers
            const letters = stimulusString.split('');
            let space = '';
            switch (spacingType) {
                case 'double': space = '\u00A0'; break; // Non-breaking space
                case 'triple': space = '\u00A0\u00A0'; break; // Two non-breaking spaces
                default: space = ''; break; // Single spacing (no extra space)
            }
            return letters.join(space);
        }

        // Function to switch between screens
        function showScreen(screenId) {
             console.log("Switching to screen:", screenId);
             screens.forEach(screen => {
                 if (screen.id === screenId) {
                     screen.classList.add('active');
                 } else {
                     screen.classList.remove('active');
                 }
             });
         }

        // --- Define Trials (Modified for Noise Condition & Trial Count) ---
        function setupTrials() {
            const letters = { set1: ['A', 'K'], set2: ['L', 'R'] }; // Target Sets
            // Condition Definitions:
            // 'noise:no' = target letter only
            // 'noise:yes' = target + flankers (congruent/incongruent)
            // 'spacing' only applies meaningfully when noise=yes
            const conditions = {
                congruency: ['congruent', 'incongruent', 'neutral'], // Added neutral for no-noise case
                noise: ['no', 'yes'],
                spacing: ['single', 'double', 'triple', 'N/A'] // Added N/A for no-noise case
             };
            const baseTrials = [];

            for (const noiseType of conditions.noise) {
                 for (const targetSetKey in letters) {
                     const targetSet = letters[targetSetKey];
                     const flankerSet = targetSetKey === 'set1' ? letters.set2 : letters.set1;
                     const correctKey = targetSetKey === 'set1' ? 'f' : 'j';
                     const targetLetter = targetSet[Math.floor(Math.random() * targetSet.length)];

                     if (noiseType === 'no') {
                         // NO NOISE condition: Only target letter, neutral congruency, N/A spacing
                         baseTrials.push({
                             stimulus_base: targetLetter, // Only the target
                             centerLetter: targetLetter,
                             correctKey: correctKey,
                             condition_congruency: 'neutral', // Explicitly neutral
                             condition_noise: 'no',
                             condition_spacing: 'N/A', // Spacing not applicable
                             touchFHandler: null, touchJHandler: null
                         });
                     } else {
                         // YES NOISE condition: Iterate through congruency and spacing
                         for (const cong of ['congruent', 'incongruent']) { // Exclude neutral here
                             for (const spacingType of ['single', 'double', 'triple']) { // Exclude N/A here
                                 let stimulusString = "";
                                 if (cong === 'congruent') {
                                     stimulusString = targetLetter.repeat(5);
                                 } else { // incongruent
                                     const flankerLetter = flankerSet[Math.floor(Math.random() * flankerSet.length)];
                                     stimulusString = `${flankerLetter}${flankerLetter}${targetLetter}${flankerLetter}${flankerLetter}`;
                                 }
                                 baseTrials.push({
                                     stimulus_base: stimulusString,
                                     centerLetter: targetLetter,
                                     correctKey: correctKey,
                                     condition_congruency: cong,
                                     condition_noise: 'yes',
                                     condition_spacing: spacingType,
                                     touchFHandler: null, touchJHandler: null
                                 });
                             }
                         }
                     }
                 }
             }

             // Calculate base trial count: 2 noise types * 2 target sets = 4 basic loops.
             // No Noise: 4 loops * 1 trial each = 4 base trials
             // Yes Noise: 4 loops * 2 congruency * 3 spacing = 24 base trials
             // Total base trials = 4 + 24 = 28.

             const repeatedTrials = [];
             // Target ~150 trials. 150 / 28 ≈ 5.35. Let's use reps = 5 or 6.
             const reps = 6; // 28 * 6 = 168 trials. Set to 5 for 140 if preferred.
             console.log(`Base trial types: ${baseTrials.length}. Repetitions: ${reps}. Total trials: ${baseTrials.length * reps}`);

             for (let i = 0; i < reps; i++) {
                 repeatedTrials.push(...baseTrials.map(trial => ({ ...trial })));
             }
             trials = shuffleArray(repeatedTrials);
             currentTrialIndex = 0;
             results = []; // Clear previous results
             console.log(`Trial setup complete: ${trials.length} trials generated.`);
         }


        // --- NEW: Send Group 1 Notification ---
        function sendGroup1Notification() {
            console.log("Group 1 selected. Attempting to send notification trigger.");
            if (!participantData.id) {
                console.error("Cannot send Group 1 notification without Participant ID.");
                return; // Don't send if ID is missing
            }

            const payload = {
                eventType: 'group1Selection', // Add a flag to identify this type of POST
                participantId: participantData.id,
                timestamp: new Date().toISOString(),
                // Add other participant data if needed by your script
                age: participantData.age,
                gender: participantData.gender
             };

             fetch(GOOGLE_SCRIPT_URL, { // Use the same URL or a dedicated one
                 method: "POST",
                 headers: { "Content-Type": "application/json" },
                 body: JSON.stringify(payload),
                 mode: 'no-cors' // Likely needed for GAS
             })
             .then(() => {
                 console.log("Group 1 notification trigger fetch initiated (mode: no-cors). Check Apps Script logs.");
                 // No reliable success confirmation here in no-cors mode
             })
             .catch(error => {
                 console.error("❌ Error initiating fetch for Group 1 notification:", error);
                 // Optionally inform the user, but might be disruptive
                 // infoErrorDiv.textContent = "Could not send Group 1 notification trigger.";
             });
         }

         // --- NEW: Countdown Timer Logic ---
         function startCountdown(durationSeconds, displayElement, callback) {
             // Clear any existing interval
             if (countdownIntervalId) {
                 clearInterval(countdownIntervalId);
             }
             countdownError.textContent = ''; // Clear errors
             let timer = durationSeconds;
             displayElement.style.display = 'block'; // Show countdown display

             countdownIntervalId = setInterval(() => {
                 let minutes = parseInt(timer / 60, 10);
                 let seconds = parseInt(timer % 60, 10);

                 minutes = minutes < 10 ? "0" + minutes : minutes;
                 seconds = seconds < 10 ? "0" + seconds : seconds;

                 displayElement.textContent = minutes + ":" + seconds;

                 if (--timer < 0) {
                     clearInterval(countdownIntervalId);
                     countdownIntervalId = null;
                     displayElement.textContent = "00:00";
                     if (callback) callback(); // Execute callback when done
                 }
             }, 1000);
         }

        // --- Experiment Flow Control ---

        // 1. Initial Continue Button
        continueToInfoBtn.addEventListener('click', () => {
            showScreen('participantInfo');
            infoErrorDiv.textContent = ''; // Clear any previous errors
        });

        // 2. Group Selection Buttons
        group1Btn.addEventListener('click', (e) => {
            selectedGroupInput.value = e.target.dataset.group;
            group1Btn.classList.add('selected');
            group2Btn.classList.remove('selected');
            group1Btn.disabled = true; // Disable after selection
            group2Btn.disabled = true;
            console.log("Group selected:", selectedGroupInput.value);
        });
        group2Btn.addEventListener('click', (e) => {
            selectedGroupInput.value = e.target.dataset.group;
            group2Btn.classList.add('selected');
            group1Btn.classList.remove('selected');
            group1Btn.disabled = true; // Disable after selection
            group2Btn.disabled = true;
            console.log("Group selected:", selectedGroupInput.value);
        });

        // 3. Info Form Submission
        infoForm.addEventListener('submit', (event) => {
            event.preventDefault();
            infoErrorDiv.textContent = ''; // Clear previous errors

            const id = participantIdInput.value.trim();
            const age = ageInput.value;
            const gender = genderInput.value;
            const group = selectedGroupInput.value;

            // Validation: Check if ID is not empty, age is valid, gender selected, group selected
            if (id && age && parseInt(age) > 0 && gender && group) {
                participantData = { id: id, age: parseInt(age), gender: gender, group: group };
                console.log("Participant Info Submitted:", participantData);

                // Send notification only if Group 1 was selected
                if (group === 'Group 1') {
                    sendGroup1Notification(); // Asynchronous call
                }

                // Proceed to the next screen
                showScreen('eyesClosedScreen');
                // Reset eyes closed screen state
                startCountdownBtn.style.display = 'inline-block';
                startCountdownBtn.disabled = false;
                continueAfterRestBtn.style.display = 'none';
                eyesClosedCountdown.style.display = 'none';
                eyesClosedCountdown.textContent = '';
                countdownError.textContent = '';

            } else {
                let errorMsg = "Please correct the following: ";
                if (!id) errorMsg += "Participant ID is required. ";
                if (!age || parseInt(age) <= 0) errorMsg += "Valid age is required. ";
                if (!gender) errorMsg += "Gender selection is required. ";
                if (!group) errorMsg += "Group selection is required. ";
                infoErrorDiv.textContent = errorMsg.trim();
             }
        });

         // 4. Eyes Closed Screen Logic
         startCountdownBtn.addEventListener('click', () => {
             startCountdownBtn.disabled = true; // Prevent multiple clicks
             startCountdownBtn.style.display = 'none'; // Hide start button
             eyesClosedCountdown.textContent = 'Starting...'; // Initial text

             // Start the countdown
             startCountdown(EYES_CLOSED_DURATION_SECONDS, eyesClosedCountdown, () => {
                 // This is the callback function executed when the timer finishes
                 console.log("Eyes closed period finished.");
                 eyesClosedText.textContent = "Thank you. Please open your eyes."; // Update text
                 continueAfterRestBtn.style.display = 'inline-block'; // Show continue button
                 eyesClosedCountdown.style.color = 'green'; // Optional: change color
             });
         });

         continueAfterRestBtn.addEventListener('click', () => {
             showScreen('preTaskInstructions');
             // Optional: copy instructions dynamically if needed
             // instructionListReminder.innerHTML = document.getElementById('instructionList').innerHTML;
         });

         // 5. Pre-Task Instructions Screen Logic
         startFlankerTaskBtn.addEventListener('click', () => {
             console.log("Starting Flanker Task...");
             showScreen('task');
             startExperiment(); // Call the function that sets up and runs trials
         });


        // --- Flanker Task Core Logic ---

        function startExperiment() {
             console.log("Initializing Flanker Task trials for:", participantData);
             experimentStartTime = performance.now(); // Start timing the task itself
             setupTrials(); // Generate and shuffle trials
             if (trials.length > 0) {
                // Hide unused elements initially
                stimulusDiv.textContent = '';
                stimulusDiv.classList.add('hidden'); // Hide stimulus initially
                feedbackDiv.textContent = '';
                feedbackDiv.classList.add('hidden'); // Hide feedback initially
                touchControlsDiv.classList.add('hidden'); // Hide touch controls initially
                fixationDiv.classList.add('hidden'); // Hide fixation initially

                runTrial(currentTrialIndex); // Start the first trial
             } else {
                 console.error("No trials defined! Cannot start task.");
                 // Optionally show an error message on screen
             }
         }

        function runTrial(trialIndex) {
            if (trialIndex >= trials.length) {
                endExperiment(); // End if no more trials
                return;
            }
            const currentTrial = trials[trialIndex];
            console.log(`Running Trial ${trialIndex+1}/${trials.length}`, currentTrial);

            // Clear previous timeout
            if (trialTimeoutId) clearTimeout(trialTimeoutId);
            trialTimeoutId = null;

            // Reset visuals for the trial
            stimulusDiv.classList.add('hidden');
            feedbackDiv.classList.add('hidden'); // Hide feedback from previous trial
            touchControlsDiv.classList.add('hidden'); // Hide controls during fixation
            fixationDiv.textContent = '+';
            fixationDiv.classList.remove('hidden'); // Show fixation

            // Disable response buttons during fixation
            touchButtonF.disabled = true;
            touchButtonJ.disabled = true;

            // --- Schedule Stimulus Presentation ---
            setTimeout(() => {
                try {
                    fixationDiv.classList.add('hidden'); // Hide fixation

                    // Format stimulus based on new noise definition
                    const formattedStimulus = formatStimulus(
                        currentTrial.stimulus_base,
                        currentTrial.condition_spacing,
                        currentTrial.condition_noise === 'yes'
                    );
                    stimulusDiv.innerHTML = formattedStimulus;
                    stimulusDiv.classList.remove('hidden'); // Show stimulus

                    // Show touch controls
                    touchControlsDiv.classList.remove('hidden');

                    stimulusStartTime = performance.now();

                    // --- Add Listeners ---
                    // Remove previous listeners first (safety check)
                    if (responseListener) document.removeEventListener('keydown', responseListener);
                    if (currentTrial.touchFHandler) touchButtonF.removeEventListener('click', currentTrial.touchFHandler);
                    if (currentTrial.touchJHandler) touchButtonJ.removeEventListener('click', currentTrial.touchJHandler);

                    // Add keyboard listener
                    responseListener = (event) => handleKeyPress(event, currentTrial);
                    document.addEventListener('keydown', responseListener);

                    // Add Touch Button Event Listeners
                    currentTrial.touchFHandler = () => handleKeyPress({ key: 'f' }, currentTrial);
                    touchButtonF.addEventListener('click', currentTrial.touchFHandler);

                    currentTrial.touchJHandler = () => handleKeyPress({ key: 'j' }, currentTrial);
                    touchButtonJ.addEventListener('click', currentTrial.touchJHandler);

                    // Enable response buttons now that stimulus is visible
                    touchButtonF.disabled = false;
                    touchButtonJ.disabled = false;

                    // Start the response timeout
                    trialTimeoutId = setTimeout(() => {
                        handleTimeout(currentTrial);
                    }, MAX_RESPONSE_TIME);

                } catch (error) {
                    console.error(`Error in runTrial setTimeout callback for trial ${trialIndex}:`, error);
                    // endExperiment(); // Consider ending gracefully on error
                 }
            }, FIXATION_DURATION);
        }

        function handleKeyPress(event, trial) {
            // Prevent processing if already processed
            if (results.some(r => r.trialIndex === currentTrialIndex)) return;

            const key = event.key.toLowerCase();
            if (key === 'f' || key === 'j') {
                // Clear timeout
                if (trialTimeoutId) clearTimeout(trialTimeoutId);
                trialTimeoutId = null;

                // --- Remove Listeners ---
                if (responseListener) document.removeEventListener('keydown', responseListener);
                responseListener = null;
                if (trial.touchFHandler) touchButtonF.removeEventListener('click', trial.touchFHandler);
                if (trial.touchJHandler) touchButtonJ.removeEventListener('click', trial.touchJHandler);

                // Disable buttons
                touchButtonF.disabled = true;
                touchButtonJ.disabled = true;

                const reactionTime = performance.now() - stimulusStartTime;
                const centerLower = trial.centerLetter.toLowerCase();
                const expectedKey = (['a', 'k'].includes(centerLower)) ? 'f' : (['l', 'r'].includes(centerLower) ? 'j' : '?');
                const correct = key === expectedKey;

                // Hide stimulus elements
                stimulusDiv.classList.add('hidden');
                touchControlsDiv.classList.add('hidden');

                // --- Record Result ---
                results.push({
                    participantId: participantData.id,
                    age: participantData.age,
                    gender: participantData.gender,
                    group: participantData.group, // Store selected group
                    trialIndex: currentTrialIndex,
                    stimulus: trial.stimulus_base, // Base stimulus string
                    centerLetter: trial.centerLetter,
                    congruency: trial.condition_congruency,
                    noise: trial.condition_noise,
                    spacing: trial.condition_spacing,
                    response: key,
                    correctKey: expectedKey,
                    correct: correct ? 1 : 0,
                    latency_ms: reactionTime
                });

                showFeedback(correct ? "Correct" : "Incorrect");

                // Schedule next trial
                setTimeout(() => {
                    currentTrialIndex++;
                    runTrial(currentTrialIndex);
                }, FEEDBACK_DURATION + ITI);
            }
        }

        function handleTimeout(trial) {
            console.warn(`Timeout occurred for trial ${currentTrialIndex}`);
            trialTimeoutId = null;
            // Prevent processing if already processed
            if (results.some(r => r.trialIndex === currentTrialIndex)) return;

            // --- Remove Listeners ---
            if (responseListener) document.removeEventListener('keydown', responseListener);
            responseListener = null;
            if (trial.touchFHandler) touchButtonF.removeEventListener('click', trial.touchFHandler);
            if (trial.touchJHandler) touchButtonJ.removeEventListener('click', trial.touchJHandler);

            // Disable buttons
            touchButtonF.disabled = true;
            touchButtonJ.disabled = true;

            // Hide stimulus elements
            stimulusDiv.classList.add('hidden');
            touchControlsDiv.classList.add('hidden');

            // --- Record Timeout Result ---
            results.push({
                participantId: participantData.id,
                age: participantData.age,
                gender: participantData.gender,
                group: participantData.group, // Store selected group
                trialIndex: currentTrialIndex,
                stimulus: trial.stimulus_base,
                centerLetter: trial.centerLetter,
                congruency: trial.condition_congruency,
                noise: trial.condition_noise,
                spacing: trial.condition_spacing,
                response: 'timeout',
                correctKey: trial.correctKey,
                correct: 0,
                latency_ms: -1
            });

            showFeedback("Too Slow");

            // Schedule next trial
            setTimeout(() => {
                currentTrialIndex++;
                runTrial(currentTrialIndex);
            }, FEEDBACK_DURATION + ITI);
        }

        function showFeedback(message) { /* ... (same as before, maybe clear text first) ... */
             feedbackDiv.textContent = ''; // Clear previous
             feedbackDiv.className = ''; // Clear classes
             feedbackDiv.classList.remove('hidden'); // Ensure visible
             if (message === "Correct") {
                 feedbackDiv.classList.add('correct');
                 feedbackDiv.textContent = "Correct";
             } else { // Handles "Incorrect" or "Too Slow"
                 feedbackDiv.classList.add('incorrect');
                 feedbackDiv.textContent = message;
             }
         }

        function endExperiment() {
            const experimentEndTime = performance.now();
            const totalElapsedTime_ms = experimentEndTime - experimentStartTime;
            console.log("Flanker Task ended. Calculating metrics...");
            taskDiv.classList.remove('active'); // Hide task screen
            touchControlsDiv.classList.add('hidden'); // Ensure buttons hidden

            // --- Calculate Summary Metrics (adapted for new conditions if needed) ---
            let correctCount = 0; let totalCorrectRT = 0; let correctRTs = [];
            let noiseYesCorrect = 0, noiseYesTotal = 0; let noiseNoCorrect = 0, noiseNoTotal = 0;
            // Spacing analysis might need adjustment if 'N/A' is used
            let spacingSingleCorrect = 0, spacingSingleTotal = 0;
            let spacingDoubleCorrect = 0, spacingDoubleTotal = 0;
            let spacingTripleCorrect = 0, spacingTripleTotal = 0;
            let timeoutCount = 0;

            results.forEach(res => {
                 // Tally totals for conditions that exist in the results
                 if (res.noise === 'yes') noiseYesTotal++; else if (res.noise === 'no') noiseNoTotal++;
                 if (res.spacing === 'single') spacingSingleTotal++;
                 else if (res.spacing === 'double') spacingDoubleTotal++;
                 else if (res.spacing === 'triple') spacingTripleTotal++;
                 // Ignore 'N/A' spacing for accuracy calculations by spacing type

                 if (res.response === 'timeout') {
                     timeoutCount++;
                 } else if (res.correct === 1) {
                     correctCount++;
                     if (res.latency_ms !== -1) { // Exclude timeouts from RT calcs
                         totalCorrectRT += res.latency_ms;
                         correctRTs.push(res.latency_ms);
                     }
                     // Tally correct counts by condition
                     if (res.noise === 'yes') noiseYesCorrect++; else if (res.noise === 'no') noiseNoCorrect++;
                     if (res.spacing === 'single') spacingSingleCorrect++;
                     else if (res.spacing === 'double') spacingDoubleCorrect++;
                     else if (res.spacing === 'triple') spacingTripleCorrect++;
                 }
             });

            const totalTrials = results.length;
            const respondedTrials = totalTrials - timeoutCount;
            // Calculate metrics safely (handle division by zero)
            const overallAccuracy = totalTrials > 0 ? (correctCount / totalTrials) * 100 : 0;
            const accuracyResponded = respondedTrials > 0 ? (correctCount / respondedTrials) * 100 : 0;
            const overallErrorRate = 100 - overallAccuracy;
            const overallMeanRT = correctRTs.length > 0 ? (totalCorrectRT / correctRTs.length) : 0;
            const overallSDRT = calculateSD(correctRTs, overallMeanRT);
            const overallMinRT = correctRTs.length > 0 ? Math.min(...correctRTs) : 0;
            const overallMaxRT = correctRTs.length > 0 ? Math.max(...correctRTs) : 0;
            const overallMedianRT = calculateMedian(correctRTs);

            // Accuracy by condition - handle division by zero
            const accuracyNoiseYes = noiseYesTotal > 0 ? (noiseYesCorrect / noiseYesTotal) * 100 : (noiseYesTotal === 0 ? NaN : 0); // NaN if condition didn't run
            const accuracyNoiseNo = noiseNoTotal > 0 ? (noiseNoCorrect / noiseNoTotal) * 100 : (noiseNoTotal === 0 ? NaN : 0);
            const accuracySpacingSingle = spacingSingleTotal > 0 ? (spacingSingleCorrect / spacingSingleTotal) * 100 : (spacingSingleTotal === 0 ? NaN : 0);
            const accuracySpacingDouble = spacingDoubleTotal > 0 ? (spacingDoubleCorrect / spacingDoubleTotal) * 100 : (spacingDoubleTotal === 0 ? NaN : 0);
            const accuracySpacingTriple = spacingTripleTotal > 0 ? (spacingTripleCorrect / spacingTripleTotal) * 100 : (spacingTripleTotal === 0 ? NaN : 0);

            summaryMetrics = {
                totalTaskTime_s: (totalElapsedTime_ms / 1000).toFixed(2), // Renamed for clarity
                totalTrials: totalTrials, timeoutCount: timeoutCount,
                overallAccuracy: overallAccuracy.toFixed(2),
                overallErrorRate: overallErrorRate.toFixed(2),
                accuracyAmongResponded: accuracyResponded.toFixed(2),
                overallMeanRT_ms: overallMeanRT.toFixed(2), overallMedianRT_ms: overallMedianRT.toFixed(2),
                overallMinRT_ms: overallMinRT.toFixed(2), overallMaxRT_ms: overallMaxRT.toFixed(2), overallSDRT_ms: overallSDRT.toFixed(2),
                // Add new noise accuracies, handle NaN for display
                accuracyNoiseYes: isNaN(accuracyNoiseYes) ? 'N/A' : accuracyNoiseYes.toFixed(2),
                accuracyNoiseNo: isNaN(accuracyNoiseNo) ? 'N/A' : accuracyNoiseNo.toFixed(2),
                accuracySpacingSingle: isNaN(accuracySpacingSingle) ? 'N/A' : accuracySpacingSingle.toFixed(2),
                accuracySpacingDouble: isNaN(accuracySpacingDouble) ? 'N/A' : accuracySpacingDouble.toFixed(2),
                accuracySpacingTriple: isNaN(accuracySpacingTriple) ? 'N/A' : accuracySpacingTriple.toFixed(2),
             };
            console.log("Summary Metrics:", summaryMetrics);

            // --- Display Summary ---
            summaryResultsDiv.innerHTML = `
                <ul>
                    <li>Total Task Time: ${summaryMetrics.totalTaskTime_s} seconds</li>
                    <li>Participant Group: ${participantData.group || 'N/A'}</li>
                    <li>Overall Accuracy (incl. Timeouts): ${summaryMetrics.overallAccuracy}% (${correctCount}/${totalTrials})</li>
                    <li>Timeouts: ${summaryMetrics.timeoutCount}</li>
                    <li>Accuracy (Responded Trials Only): ${summaryMetrics.accuracyAmongResponded}%</li>
                    <li>Mean Correct Latency (Responded Trials): ${summaryMetrics.overallMeanRT_ms} ms</li>
                    <li>Median Correct Latency (Responded Trials): ${summaryMetrics.overallMedianRT_ms} ms</li>
                    <li>Latency Range (Min-Max, Correct & Responded): ${summaryMetrics.overallMinRT_ms} - ${summaryMetrics.overallMaxRT_ms} ms</li>
                    <li>Accuracy by Condition (Target Alone / Target+Flankers): ${summaryMetrics.accuracyNoiseNo}% / ${summaryMetrics.accuracyNoiseYes}%</li>
                    <li>Accuracy by Spacing (Single / Double / Triple): ${summaryMetrics.accuracySpacingSingle}% / ${summaryMetrics.accuracySpacingDouble}% / ${summaryMetrics.accuracySpacingTriple}%</li>
                </ul>`;
            showScreen('summary'); // Show summary screen

            // --- Prepare and Send Data to Google Sheet ---
            console.log("Preparing final data payload for Google Sheet...");
            const dataForSheet = {
                eventType: 'experimentData', // Flag for Apps Script
                participantID: participantData.id,
                age: participantData.age,
                gender: participantData.gender,
                group: participantData.group, // Include group in final data
                rawData: results, // Full raw data array
                summaryData: summaryMetrics // Full summary metrics object
            };
            sendDataToSheetGoogle(dataForSheet); // Call the sending function
        }

        function convertToCSV(dataArray) { /* ... (same as before, ensure 'group' header is added if needed) ... */
             if (!dataArray || dataArray.length === 0) return "";
             // Add 'group' to headers
             const headers = [
                 'participantId', 'age', 'gender', 'group', 'trialIndex', 'stimulus', 'centerLetter',
                 'congruency', 'noise', 'spacing', 'response', 'correctKey', 'correct', 'latency_ms'
             ];
             const csvRows = [ headers.join(',') ]; // Header row

             dataArray.forEach(row => {
                 const values = headers.map(header => {
                     let value = row[header];
                     if (value === null || typeof value === 'undefined') value = '';
                     if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                         value = `"${value.replace(/"/g, '""')}"`;
                      }
                     return value;
                  });
                 csvRows.push(values.join(','));
              });
             return csvRows.join('\n');
          }

        // --- Restart Logic ---
        restartBtn.addEventListener('click', () => {
            // Reset state variables
            participantData = {};
            results = [];
            summaryMetrics = {};
            currentTrialIndex = 0;
            if (countdownIntervalId) clearInterval(countdownIntervalId); // Stop timer if running
            countdownIntervalId = null;

            // Reset UI elements
            infoForm.reset(); // Reset form fields
            participantIdInput.value = '';
            ageInput.value = '';
            genderInput.value = '';
            selectedGroupInput.value = '';
            group1Btn.classList.remove('selected');
            group2Btn.classList.remove('selected');
            group1Btn.disabled = false; // Re-enable group buttons
            group2Btn.disabled = false;
            infoErrorDiv.textContent = '';
            countdownError.textContent = '';

            // Show the very first screen
            showScreen('instructions');
        });

        // --- Initial Setup ---
        infoErrorDiv.textContent = ''; // Ensure error message is clear initially
        countdownError.textContent = '';


        // --- Google Sheet Sending Function ---
        // This function now sends WHATEVER payload it's given.
        // The payload structure determines what the Apps Script should do.
        function sendDataToSheetGoogle(payload) {
          console.log("Attempting to send payload via fetch:", JSON.stringify(payload).substring(0, 500) + "...");

          fetch(GOOGLE_SCRIPT_URL, { // Use the single configured URL
            method: "POST",
            headers: { "Content-Type": "application/json", },
            body: JSON.stringify(payload), // Send the prepared payload
            mode: 'no-cors'
          })
          .then(() => {
           console.log("Payload submission fetch initiated (mode: no-cors). Check Google Sheet/Apps Script Logs.");
          })
          .catch((error) => {
            console.error("❌ Error initiating fetch to Google Sheet URL:", error);
            // Avoid alerting for Group 1 trigger, maybe only for final data?
            if (payload.eventType === 'experimentData') {
                 alert("A network error occurred while trying to send final data. Please check connection/console.");
            }
          });
       }

    </script>

    </body>
</html>
